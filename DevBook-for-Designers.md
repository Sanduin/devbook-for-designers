# Про код, дистрибутив, сборку дистрибутива, тестирование, приемо-сдаточные испытания, промышленную эксплуатацию

## Глава I. Программисты и непрерывная интеграция

### Как работают программисты
Дисклеймер: в нашем общем случае, программист и кодер, верстальщик и технолог — все на одно лицо: сидят и буквы пишут, отбивая каждую строчку отступами из пробелов или табуляций, назовем их «программистами» для простоты. Что они делают — для нас не существенно, язык программирования или разметки так же не важен. Если продолжать обобщать до маразма, то и работа аналитика по создание модели данных тоже можно рассматривать через призму описанного ниже.

**Аксиома:** программисты пишут код.

Что такое код? Под словом «код» в нашем случае — разработки программного обеспечения — подразумевается написание исходного (программного) кода.

*Согласно Википедии:* «[Исхо́дный код](https://ru.wikipedia.org/wiki/Исходный_код) (также исхо́дный текст) — текст [компьютерной программы](https://ru.wikipedia.org/wiki/Компьютерная_программа) на каком-либо [языке программирования](https://ru.wikipedia.org/wiki/Язык_программирования) или [языке разметки](https://ru.wikipedia.org/wiki/Язык_разметки), который может быть прочтён человеком. В обобщённом смысле — любые входные данные для [транслятора](https://ru.wikipedia.org/wiki/Транслятор). Исходный код транслируется в исполняемый код целиком до запуска программы при помощи [компилятора](https://ru.wikipedia.org/wiki/Компилятор) или может исполняться сразу при помощи [интерпретатора](https://ru.wikipedia.org/wiki/Интерпретатор)».

*Код записывается в файл.* Файл текстовый, в технических терминах обозначается как plain-text. Программа, которую пишет программист, может состоять как из одного файла (простейший, если не сказать примитивный случай), так и из десятков, сотен, тысяч, а нередко и десятков тысяч файлов с исходными кодами, порой на разных языках (не только программирования, но и разметки). В разных языках программирования различаются модели описания ссылок на так называемые модули — фрагменты исходного кода, вынесенные в отдельный файл.

*Зачем выносят исходный код в отдельный файл?* По разным причинам, начиная с разделения проекта на логические куски — файлы, — исходный код в которых написан на разных языках, заканчивая простейшим удобством разработки. Удобством в таком случае может стать как физическое ограничение plain-text файла: по достижению какого-то большого размера такой файл вызывает проблемы при чтении (исходный код читают). Или, например, разделяют, чтобы вынести в отдельный файл какие-то части программного кода, повторяющиеся во многих местах (функции и процедуры), чтобы поддерживать их независимо от основного кода.

### Куда складывают файлы с исходным кодом и как с ними работают?
Общемировая практика предлагает отказываться от хранения исходного кода только на рабочей станции программиста в единственном экземпляре. Не только по причине ненадежности одного такого хранилища и риска потерять все и сразу, так как нет копии (бэкапа, от англ. backup) на случай неработоспособности рабочей станции. В основном из-за того, что над одним проектом может, а по сути должна, работать группа специалистов: программисты, верстальщики, кодеры, аналитики и другие, в том числе и администраторы. Да-да, у всех них есть задачи автоматизации. Если у программиста это задача единственная, то у его коллег становится таковой лишь в последнее время. Пусть они не постоянно пишут исходный код, но им регулярно приходится создавать и править, например, конфигурационные файлы самых разных систем — такие файлы настроек и конфигураций также имеет смысл централизованно хранить вместе с программным продуктом и его исходным кодом.

*Централизованно хранить* означает использовать одну из [систем версионного хранения](https://ru.wikipedia.org/wiki/Система_управления_версиями) (еще их называют системами ревизионного хранения или системами управления версиями). Такие системы работают по особому принципу и различаются некоторыми нюансами внутренних процессов, команд и другими тонкими особенностями, из-за которых одни программисты любят одни системы, другие — другие ;). 

[Система ревизионного контроля](https://ru.wikipedia.org/wiki/Revision_Control_System) (Revision Control System или RCS) — прородитель систем версионного контроля, применяемых сейчас повсеместно при разработке программного кода. 

Существуют разные системы контроля версий: [Git](https://ru.wikipedia.org/wiki/Git), [Subversion](https://ru.wikipedia.org/wiki/Subversion), [Mercurial](https://ru.wikipedia.org/wiki/Mercurial). Все эти системы работают как сервис и управляются командамы из терминала (command-line tool). Для решения разных задач и построения более понятного и прозрачного процесса управления разработкой, контроля результатов и проверки предложенных решений разработан не один десяток разных реализаций таких систем. Например, Git представлен самыми популярными реализациями GitHub, Gitlab, BitBucket и Stash. Для Subversion есть реализация SVN и SVNx.

Чтобы вам не запутаться, что есть что — система версионного контроля или ее частная реализация — достаточно понять: система версионного контроля — система, управляющая процессом хранения, загрузки, выдачи файлов (например, Git), а конкретная реализация системы версионного контроля — частная интерпретация системы с удобным и понятным интерфейсом взаимодействия команды внутри (например, GitHub). Назвав GitHub системой версионного контроля, вы *не ошибетесь*, пусть это и не совсем корректно.

Итого, написанный программистом и сохраненный в файл код попадает в систему версионного контроля и хранится как на локальной машине, так и в централизованном хранилище где-то на сервере, для которого есть резервирование (дублирование, сохранение копии). Если программист один — нет никаких проблем, он может копировать рабочую папку проекта и не заботиться о версионном контроле (в теории), но что делать, когда программистов много?

### Нафига нужна система версионного контроля и как она работает?
О, это прекрасный вопрос. Система версионного контроля позволяет группе программистов параллельно заниматься различными задачами в проекте и писать свои кусочки исходного кода в один и тот же проект. По сути — редактировать одни и те же файлы единовременно. Чтобы после этой работы результат их труда выглядел как единое целое, требуется проводить процедуру синхронизации. Раньше, в эпоху отсутствия систем версионного контроля, это делали вручную. Не спрашивайте как. Это было либо очень топорное решение, когда один программист говорил другому о своих намерениях в одном из файлов с исходным кодом что-то поправить, тогда второй просто не трогал этот файл. Либо, после написания кода проводились ресурсоемкие процедуры сливания результатов работы двух и более программистов в единый исходный код.

Не сложно догадаться, в первом случае скорость реализации разных задач была низкой из-за отсутствия возможности параллельно работать над одним условным файлом. Во втором случае время, которые придется затратить на ручное слияние результатов параллельной работы двух-трех программистов было больше, чем они каждый потратили на свою часть работы. Когда программистам надоело «работать руками», они автоматизировали свою жизнь, изобретя и разработав систему версионного контроля.

Работа системы версионного контроля заключается в реализации трех базовых потребностей:

1. Предоставить каждому программисту в команде проекта актуальную версию исходного кода, имеющуюся на центральном сервере, полностью синхронизированную со всеми — так называемая ветка Master. Процедура получения копии исходного кода называется Pull (в просторечии — «пуллить»).
2. Собирать все изменения в исходном коде от всех программистов (contributors — контрибьютеры). Процедура отправки результатов работы с исходным кодом в общее хранилище называется Push (в просторечии — «пушить»).
3. Показывать разницу между имеющимся в Master коде и новым, давая главным программистам (владельцам проекта или maintainers — мейнтейнерам) инструменты анализа полученного результат и возможность принять предложенные изменения или отказаться от их применения, откатив до предыдущей версии.

Помимо основных функций есть и полезные дополнительные, которые в настоящее время давно переросли в основные:

1. Если программист не является участником проекта, которому разрешено вносить изменения в ветку Master самостоятельно через функцию Push, он может воспользоваться функцией Pull-request. Результат его работы будет отправлен в общее хранилище, но представлен как предложение-запрос на внесение изменений. Мейнтейнеры получат уведомление и смогут посмотреть предложенные изменения в удобной форме (difference), после чего принять его, отказаться от принятия или прокомментировать.
2. В случае возникновения острого желания доработать или видоизменить исходный код, но при отсутствии со стороны владельца (мейнтейнера) желания применять столь радикальные изменения, обычно нарушающие концепцию и (или) подход к разработке, инициатор изменения может сделать «форк». Функция Fork (от англ. вилка) — это создание отдельной версии проекта с исходным кодом, взятым в другом проекте и доработанным по своим лекалам и требованиям. Часть кода при этом не должна меняться, так она является, например, core-функциональность, а так же будет совершенствоваться основным разработчиком, а вот все остальное можно поменять и применять уже по правилам, созданным инициатором изменений (который сделал «форк») и в соответствии с лицензией, установленной для проекта-донора.

**Подведем краткий итог:**

1. Системы версионного контроля бывают разные, но в их основе заложен принцип автоматизации коллективной работы группы программистов с возможностью объединять коллективную работу в единое целое, централизованно хранить программный код, отменять внесенные изменения.
2. По-другому системы ревизионного контроля еще называют репозиториями. Репозиторий — это хранилище, где «лежат» файлы с исходным кодом. Это определение верно для указания на место хранения, но не на метод и принцип организации труда с использованием автоматизации процессов синхронизации результатов работы разных программистов с исходным кодом.
3. Когда вы хотите внести изменения в «чужой» код, они не попадут в него автоматически, их будут рассматривать мейнтейнеры проекта, после чего примут решение о принятии или отказе в принятии изменений. Все системы ревизионного контроля имеют функционал двустороннего общения для взаимодействия внутри одного инструмента программиста-энтузиаста с мейнтейнером.
4. Когда проект очень нравится, но хочется его достаточно радикально изменить и перестроить под себя, а договориться о такой работе с мейнтейнером не получается или не представляется возможным — делайте fork и развивайте свою версию программного продукта на основе чужого, поддерживаемого кода. Связь исходного кода в проекте-родителе останется, так что все «плюшки от папы» вы будете получать и сможете принимать решение об их включении в свой проект (часто новые функции ломают или нарушают работу ваших кардинальных изменений, так что функция проверки совместимости вместо молчаливого обновления не повредит).

### Есть ли жизнь после кода?
Безусловно, жизнь на исходном коде не заканчивается. Программисты помимо написания кода занимаются его тестированием и сборкой.

Тестирование кода или модульное тестирование — практика написания тестов до имплементации (реализации) решения в коде. Сейчас объясню по-русски. До того, как программист напишет программный код, решающий какую-то задачу, он должен придумать критерии и правила оценки успешности исполнения кода. Критерии и правила так же описывается в виде исходного кода (причем внутри проекта) — программируются в виде модульного или единичного теста (еще его называют юнит-тестом от англ. unit-testing). После этого программист разрабатывает решение задачи, запускает тест и проверяет свое решение на выполнение заранее продуманных выходных параметров. Если тест пройден — решение верно. Если нет — не верно. Смысл такого действия в том, чтобы проверять, не привело ли последующее изменение кода в рамках его совершенствования к регрессивным изменениям (не нарушился ли заданный критерий результативности). Если кто-то пришел, исправил написанный ранее код и новый вариант решения задачи провалил тест, значит произошел регресс кода — его ухудшение. Такое изменение нельзя использовать до тех пор, пока новый код не сможет пройти тест. Такая автоматизация тестирования экономит сотни часов работы десятков людей в команде.

Когда услышите кодовое слово JUnit, знайте – это библиотека для модульного тестирования Java-приложений.

### Статический анализ кода (или анализ качества кода)
Звучит сильно, богато и богоподобно. В реальности же за этими тремя словами — статический анализ кода — кроется проверка этого самого кода на банальные, не очень банальные и совсем не банальные уязвимости.

Да-да, программисты делают ошибки и могут написать код так, что его исполнение постоянно, периодически или при определенных условиях будет вызывать ошибки. Конечно, они делают это не нарочно (обычно). Существует целый классификатор ошибок, но мы его рассматривать не будем, а лишь узнаем, что в нем есть две группы: а) ошибки, вызванные написанием кода, их вызывающим; б) ошибки, появляющиеся в результате исполнения кода на конкретной платформе.

Чтобы ловить такие ошибки применяют два метода: ручной и автоматический. Ручной — проверка кода (code review): программист ставит задачу другому программисту посмотреть написанный код и всесторонне проверить его (на логику, ошибки, баги). Автоматический — проверка кода с помощью систем статического анализа: разбор кода на типичные паттерны и анализ результатов этого кода на качество без непосредственного запуска (исполнения) кода в виде программы.

Автоматический способ с каждым разом становится все лучше и лучше, набирая базу знаний о том как делать нельзя и показывая почему же написанный код — бяка. Так вот, чтобы программист ни написал, статический анализатор прогоняет код через наборы практик из лучших мировых стандартов кодирования и безопасности.

С формальной точки зрения такой анализ кода обязателен, отсутствие ошибок или предупреждений в результате анализа говорит о высоком качестве кода и его надежности в работе. Базы данных паттернов с ошибками постоянно развиваются, соответственно, качество кода на выходе после анализа и исправления сильно улучшается.

Когда услышите Sonar Qube, знайте — это названия программного продукта для статического анализа кода и проверки его на безопасность. 
 
### Проверка кода на безопасность
Плохо написанный код — не только проблема приложения, которое из-за этого в любой момент может начать работать не стабильно или вовсе перестать работать. Плохой код — потенциальная уязвимость, которую можно использовать для совершения каких-то действий, нарушающих безопасность работы системы.

Средства проверки кода на безопасность позволяют выявить потенциально опасные фрагменты, закономерности их использования в целом проекте и помочь переписать программу, сделав ее надежной. Знать как это работает вам не нужно, там все сложно и крайне сильно завязано на язык программирования и аппаратную платформу. 

Когда услышите HP Fortify, IBM AppScan, Checkmarks, знайте — это названия программных продуктов для проверки кода на безопасность. 

## От кода к дистрибутиву
Написанный код — набор символов в строчках, который кто-то должен исполнять, чтобы написанная программа начала приносить пользу, то есть работать.

Условно языки программирования разделены на компилируемые и интерпретируемые.

Компилируемые — это когда написанный программный код для исполнения на компьюетере с помощью программы, называемой компилятором, автоматически переписывается в машинный код (целиком), оптимизируется для конкретной исполняющей среды и тем самым достигается максимальная производительность и надежность программы. *Например: С, С++, Java.*

Интерпретируемые — код не превращается в машинный заранее, а передается в виде как есть в специальную программу-интерпретатор, которая занимается преобразованием написанного кода в машинный по мере его исполнения (строчка за строчкой). *Например: PHP, JavaScript.*

Каждый вариант исполнения программы — скомпилированный или интерпретированный код — имеет свои преимущества и недостатки, в рамках этого текстового произведения мы не будем их касаться. Нам важно во что превращается код, написанный программистом, проверенный разными ручными и автоматизированными средствами.

Код превращается в дистрибутив.

### Сборка дистрибутива
Под сборкой кода подразумевается не только компиляция. Сборка — комплексная работа превращения исходного кода в дистрибутив.

*Согласно Википедии*: «[Дистрибути́в](https://ru.wikipedia.org/wiki/Дистрибутив) (англ. distribute — распространять) — это форма распространения программного обеспечения».

Объяснить что это такое довольно сложно, но я попробую. Аналогия будет про апельсиновый сок. Вы хотите на завтрак выпить апельсинового сока и лезете в холодильник за бутылкой. Сам по себе апельсиновый сок — часть вашего утреннего рациона питания (завтрака). Сам же сок в бутылке — дистрибутив. Холодильник и все его окружение на кухне — программа, с помощью которой вы решаете задачу. Совершенно не важно, что помимо сока вы еще яишенку себе с беконом жарите, да тосты печете. Сок со всеми этим яствами может и работает совместно, при этом он сам — дистрибутив — вполне автономен и может быть употреблен отдельно от других продуктов питания.

Чтобы собрать дистрибутив, требуется проделать определенную работу. Вернемся к соку. Чтобы его получить, нужно взять апельсины, соковыжималку, ножик и емкость. Все это особенным образом использовать и на выходе получиться сам сок в бутылке. То есть, вы собрали нечто и чего-то другого. Так код превращается в программу через дистрибутив. Как пользоваться бутылкой и пить сок вы знаете, вас в детстве научили. С дистрибутивом еще проще, его можно применять только одним единственным образом — запускать.

Как же дистрибутивы собираются? О, это дело не простое. Не будем долго останавливаться на самом процессе, пробежим по нему как по черному ящику, но по дороге узнает названия разных приложений, которые могут попадаться вам на слух или в тексте. Вы их узнаете, вспомните откуда они и они перестанут быть для вас пустым звуком.

Разработчик написал код, сохранил его в репозитории системы версионного контроля. Главный программист или мейнтейнер проекта собрал все изменения в dev (ветка в системе контроля версий на базе Git, над которой в данный момент работает команда) и отправил результат на сборку. Такие сборки делаются постоянно, чтобы регулярно проверять результат.

Например, разработчики используют Bitbucket в качестве версионного контроля. Из ветки dev с помощью Job (задачи или «джобы») в Jenkins код направляется по специальному workflow на сборку. По дороге код проходит модульные тесты, статистический анализ и проверку на информационную безопасность. После чего чистый код отправляется в [Maven](https://ru.wikipedia.org/wiki/Apache_Maven) — фреймворк для автоматизации сборки проектов. Maven автоматизирует сборку дистрибутива для компилируемого языка Java. Для интерпретируемых языков есть свои фреймворки, например, под JavaScript придумали [npm](https://www.npmjs.com) — Node.js Package Manager. Оба этих программных продукта еще называют системами управления пакетами (или дистрибутивами). Скомпеллированный пакет = дистрибутив. Через другую Job («джобу») в Jenkins запускается отправка дистрибутива в хранилище (репозиторий дистрибутивов) — Nexus.

Все, теперь дистрибутив готов и размещен в хранилище, можно начинать его развертывание в разработческой среде.

Забегая вперед, все, что мы до этого узнали о процессе работы в методиках и практиках DevOps — это только первая из трех фаз, которая называется CI — Continuos Integration (непрерывная интеграция).

## Глава II. Куда программисты девают код или непрерывная поставка
Перед началом сложного пути дистрибутива по серверам и весям, забежим немного назад в разработку. Чтобы непрерывная поставка дистрибутивов на тестовые и разработческие стенды осуществлялась ровно и вовремя, команда разработчиков должна работать по заведенной в системах контроля версий методологии.

Так как мы работаем с Git-системами версионного контроля, то и рассматривать будем именно эту методологию. Из всего объема методологий нам потребуется только пониманием о ветвях (branch), в которых идет разработка программного продукта.

Основных (главных) ветвей две — *Master* и *Develop* (или Dev). Master-ветвь — то, что сейчас находится в продакшне и эксплуатируется клиентами. Develop-ветвь — набор всех изменений, над которыми сейчас трудятся разработчики — их песочница, где они пишут новый и правят старый код.

Помимо основных есть вспомогательные ветви, решающие частные задачи: feature branches — ветви функциональности, release branches — ветви релизов, hotfix branches — ветви исправлений.

У ветвей есть взаимосвязи, с помощью которых одни вливаются в другие и получается результат, именуемый релизом. Для нас важно понимать, что каждый коммит (commit) в ветвь Master — релиз. Чтобы не путаться в релизах и иметь возможность посмотреть состав или откатиться с новейшей версии на предыдущую, в ветке Master есть теги, которые нумеруют релизы последовательно и по заведенным для команд правилам правилам. Ветвь Develop всегда на момент релиза берет исходники из Master, чтобы разработчики имели возможность работать с уже рабочим кодом из промышленной эксплуатации.

Со вспомогательными ветвями чуть посложнее. Feature и Release образуются как из Master-, так и из Develop-ветви. А Hotfix только из Master. Hotfix всегда занимается внесением исправлений в рабочий код с целью восстановления его работоспособности и надежности, а все Feature и Develop новинки и исправления, не являющиеся критическими идут отдельно и параллельно. Послче все исправления и новые разработки можно объединить в Master.

На этом остановимся, больше про ветки в системах версионного контроля нам знать ничего не нужно, а то голова лопнет.

### Поставка дистрибутива в среду разработки
С определением дистрибутива уже разобрались, теперь разберемся что за среда разработки такая вдруг возникает в работе разработчиков.

Среда разработки или разработческий сервер — физическая или виртуальная машина (оборудование), на которой предустановлено необходимое ПО, окружение, пакеты, веб-сервер и все прочее, необходимое для развертывания дистрибутива и запуска программы (приложения). Например, для запуска Java-приложения может потребоваться Java-окружение и сервер приложений. А еще может понадобиться локальная база данных, запущенная внутри среды разработки для оперативного хранения данных или содержащая тестовые данные для оценки новой функциональности. Пакеты — это кусочки других программ или того же приложения, по сути другие дистрибутивы из состава продукта, требующиеся для запуска и работы созданного программного решения. В дополнение на разработческом сервере может быть установлено или подключено к нему дополнительное ПО для сбора и хранения лог-файлов (от англ. logging — регистрация, запись [показаний прибора]).

Представьте себе ситуацию: вы — программист, написали новый кусочек функциональности большого продукта и решили проверить его работу, так сказать, покопаться в результате, прогнать тестовые данные и собрать логи. Собрав дистрибутив, вы хотите развернуть его на своем выделенном разработческом стенде. Допустим, у вас нет ограничений в материалом обеспечении и «железа» предостаточно для выполнения любой вашей прихоти. Теперь дело за малым: вам нужно накатить на ваше «железо» операционную систему, установить и настроить на ней сервер приложений, веб-сервер, разные приложения получения дистрибутивов из хранилищ, ведь вам нужны только стабильные и последние пакеты, не руками же все это делать, после чего вы собираете все из кусочков и запускаете свой продукт. Далее устанавливаете, настраиваете и заливаете свежие тестовые данные в базу данных, соединяете ее с вашей разработкой. А еще устанавливаете и настраиваете или хотя бы подключаете к централизованной системе логгирования. Если вы хоть раз в жизни переустанавливали с нуля операционную систему на своем компьютере, знаете как это долго и муторно. Разработчеку же может потребоваться протестировать на тестовых данных результат своей работы не один, не два, а, например, пять раз в день. И каждый раз нужно повторить все с самого начала для чистоты эксперимента, а лучше (для сравнения) иметь запущенными разные версии разработческих сред и проводить отладку кода, ориентируясь на сравнительные данные из лог-файлов разных версий дистрибутивов.

Ох, кажется это каторга. Вовсе нет, весь процесс давно научились автоматизировать на столько, что программисту достаточно нажать кнопочку Run в процессе развертывания среды на выделенном сервере или в виртуальной машине, а все остальное будет сделано за него автоматически и очень быстро, без ошибок и станет доступно сразу по завершению процесса развертывания. Можно сразу вводить логин и пароль от SSH-соединения и подключаться к серверу, отправлять на него какие-то команды, собирать данные о работе приложения, анализировать и вообще выполнять нормальную, не рутинную работу.

Во время развертывания дистрибутива происходит некоторая магия, запускаются разные приложения и фреймворки, автоматизирующие процесс. Когда вы услышите, что для сборки дистрибутива используется Jenkins, в котором запускаются соответствующие «джобы» (Jobs), после чего дистрибутив попадает в Nexus, где хранится. Это половина дела. Дальше вступает тяжелая артиллерия: автоматически загружаются нужные тестовые данные, а также осуществляется автоматическое конфигурирование среды с помощью Ansible — программы-оркестратора.

**Ansible** — это программное решение для удаленного управления конфигурациями. Оно позволяет настраивать удаленные машины.

Ура, машина настроена, дистрибутив залит, развернут и запущен, можно начинать его осматривать, собирать и изучать собранные лог-файлы. На основе этих данных получается решение о качестве работы написанного решения, полнота покрытия тестовыми данными и работоспособность в тестовой среде.

### Отладка кода
Среда разработки нужна для проверки решения, но так же может пригодиться и для отладки кода. Здесь мы снова возвращаемся к непосредственной работе программистов.

Согласно Википедии: «[Отла́дка](https://ru.wikipedia.org/wiki/Отладка_программы) (программы) — этап разработки компьютерной программы, на котором обнаруживают, локализуют и устраняют ошибки». Определение крайне бесполезное, особенно в суровых реалиях программирования в XXI веке. Существует два лагеря программистов: 1) которые отлаживают код, 2) которые пишут изначально корректный код, не требующий отладки. Сами понимаете, это непримиримые стороны, находящиеся в войне.

Для большинства языков программирования в [интегрированной среде разработки](https://ru.wikipedia.org/wiki/Интегрированная_среда_разработки) (англ. Integrated development environment — IDE) есть встроенный и встраиваемый отладчик (debugger). Отладчик — специальная программа, помогающая выявить причину плохой, некорректной или вовсе неработающей части кода.

Когда отладчика нет или к нему не прибегают по «религиозным» причинам, на помощь приходят тесты. С модульными тестами (юнит-тестирование) мы уже познакомились в первой главе. Кроме юнит-тестов есть и другие, помогающие объективно оценить предложенное программное решение. Например, «дымовое» тестирование или «[смоук тест](https://ru.wikipedia.org/wiki/Smoke_test)» (от англ. Smoke Test). «Смоук тест» — набор примитивных тестов, проверяющих работоспособность программы. Если программа не проходит «смоук тесты», она не готова идти по процессу дальше и ее код требует существенной доработки. Так как «смоук тесты» легко поддаются автоматизации, этот этап тестирования во время отладки (или вместо него) практически стал стандартом де-факто в разработке ПО.

Еще один способ отладки — внедрение в код специальных средств сбора данных о выполнении программы. В код встраиваются различные выводы (на экран или в файл), которые записывают «каждый чих» в ходе выполнения программы так, что при возникновении какой-то ошибки, можно быстро найти запись с такого вывода и понять где именно программа сбоит. Использование экранного анализа — вывода данных о ходе исполнения программы на экран — крайне затруднительно для больших и сложных проектов из-за объема данных, которые на него будут выводиться. А вот вывод в файл — вполне логичная реализация. Сохраненные файлы — логи – после можно открыть в удобном редакторе и анализировать с комфортом. Вывод отладочных сведений в файл называется журналированием. Для чтения журналов (лог-файлов) могут применяться специальные программные решения, умеющие показывать огромные файлы с записями о действиях более наглядно и  сгруппированно показано на экране для зрительного анализа человеком.

Когда программа отлажена, прошла модульные и «смоук» тесты, собрана в дистрибутив как финальная версия в рамках готовящегося релиза, самое время ее протестировать всесторонне и более тщательно.

### Поставка на тестовые стенды
Аналогично поставке на разработческий стенд (в разработческую среду), для проведения более глубоких и интеллектуальных тестов требуется поставка программы на тестовые стенды. В зависимости от набора тестов, которые должна пройти программа внутри тестового конвеера, число таких стендов может сильно разниться для каждого дистрибутива.

Продолжение следует...

---
Далее в книге:
### Тестирование

## От дистрибутива к релиз-кандидату и релизу
### Комплексное автоматизированное тестирование
### Выход на ПСИ
### Выход в ПРОМ
### DevOps
