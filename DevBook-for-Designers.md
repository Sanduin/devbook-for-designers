# Про код, дистрибутив, сборку дистрибутива, тестирование, приемо-сдаточные испытания, промышленную эксплуатацию

## Глава I. Программисты

### Как работают программисты
Дисклеймер: в нашем общем случае, программист и кодер, верстальщик и технолог — все на одно лицо: сидят и буквы пишут, отбивая каждую строчку отступами из пробелов или табуляций, назовем их «программистами» для простоты. Что они делают — для нас не существенно, язык программирования или разметки так же не важен. Если продолжать обобщать до маразма, то и работа аналитика по создание модели данных тоже можно рассматривать через призму описанного ниже.

**Аксиома:** программисты пишут код.

Что такое код? Под словом «код» в нашем случае — разработки программного обеспечения — подразумевается написание исходного (программного) кода.

*Согласно Википедии:* «[Исхо́дный код](https://ru.wikipedia.org/wiki/Исходный_код) (также исхо́дный текст) — текст [компьютерной программы](https://ru.wikipedia.org/wiki/Компьютерная_программа) на каком-либо [языке программирования](https://ru.wikipedia.org/wiki/Язык_программирования) или [языке разметки](https://ru.wikipedia.org/wiki/Язык_разметки), который может быть прочтён человеком. В обобщённом смысле — любые входные данные для [транслятора](https://ru.wikipedia.org/wiki/Транслятор). Исходный код транслируется в исполняемый код целиком до запуска программы при помощи [компилятора](https://ru.wikipedia.org/wiki/Компилятор) или может исполняться сразу при помощи [интерпретатора](https://ru.wikipedia.org/wiki/Интерпретатор)».

*Код записывается в файл.* Файл текстовый, в технических терминах обозначается как plain-text. Программа, которую пишет программист, может состоять как из одного файла (простейший, если не сказать примитивный случай), так и из десятков, сотен, тысяч, а нередко и десятков тысяч файлов с исходными кодами, порой на разных языках (не только программирования, но и разметки). В разных языках программирования различаются модели описания ссылок на так называемые модули — фрагменты исходного кода, вынесенные в отдельный файл.

*Зачем выносят исходный код в отдельный файл?* По разным причинам, начиная с разделения проекта на логические куски — файлы, — исходный код в которых написан на разных языках, заканчивая простейшим удобством разработки. Удобством в таком случае может стать как физическое ограничение plain-text файла: по достижению какого-то большого размера такой файл вызывает проблемы при чтении (исходный код читают). Или, например, разделяют, чтобы вынести в отдельный файл какие-то части программного кода, повторяющиеся во многих местах (функции и процедуры), чтобы поддерживать их независимо от основного кода.

### Куда складывают файлы с исходным кодом и как с ними работают?
Общемировая практика предлагает отказываться от хранения исходного кода только на рабочей станции программиста в единственном экземпляре. Не только по причине ненадежности одного такого хранилища и риска потерять все и сразу, так как нет копии (бэкапа, от англ. backup) на случай неработоспособности рабочей станции. В основном из-за того, что над одним проектом может, а по сути должна, работать группа специалистов: программисты, верстальщики, кодеры, аналитики и другие, в том числе и администраторы. Да-да, у всех них есть задачи автоматизации. Если у программиста это задача единственная, то у его коллег становится таковой лишь в последнее время. Пусть они не постоянно пишут исходный код, но им регулярно приходится создавать и править, например, конфигурационные файлы самых разных систем — такие файлы настроек и конфигураций также имеет смысл централизованно хранить вместе с программным продуктом и его исходным кодом.

*Централизованно хранить* означает использовать одну из [систем версионного хранения](https://ru.wikipedia.org/wiki/Система_управления_версиями) (еще их называют системами ревизионного хранения или системами управления версиями). Такие системы работают по особому принципу и различаются некоторыми нюансами внутренних процессов, команд и другими тонкими особенностями, из-за которых одни программисты любят одни системы, другие — другие ;). 

[Система ревизионного контроля](https://ru.wikipedia.org/wiki/Revision_Control_System) (Revision Control System или RCS) — прородитель систем версионного контроля, применяемых сейчас повсеместно при разработке программного кода. 

Существуют разные системы контроля версий: [Git](https://ru.wikipedia.org/wiki/Git), [Subversion](https://ru.wikipedia.org/wiki/Subversion), [Mercurial](https://ru.wikipedia.org/wiki/Mercurial). Все эти системы работают как сервис и управляются командамы из терминала (command-line tool). Для решения разных задач и построения более понятного и прозрачного процесса управления разработкой, контроля результатов и проверки предложенных решений разработан не один десяток разных реализаций таких систем. Например, Git представлен самыми популярными реализациями GitHub, Gitlab, BitBucket и Stash. Для Subversion есть реализация SVN и SVNx.

Чтобы вам не запутаться, что есть что — система версионного контроля или ее частная реализация — достаточно понять: система версионного контроля — система, управляющая процессом хранения, загрузки, выдачи файлов (например, Git), а конкретная реализация системы версионного контроля — частная интерпретация системы с удобным и понятным интерфейсом взаимодействия команды внутри (например, GitHub). Назвав GitHub системой версионного контроля, вы *не ошибетесь*, пусть это и не совсем корректно.

Итого, написанный программистом и сохраненный в файл код попадает в систему версионного контроля и хранится как на локальной машине, так и в централизованном хранилище где-то на сервере, для которого есть резервирование (дублирование, сохранение копии). Если программист один — нет никаких проблем, он может копировать рабочую папку проекта и не заботиться о версионном контроле (в теории), но что делать, когда программистов много?

### Нафига нужна система версионного контроля и как она работает?
О, это прекрасный вопрос. Система версионного контроля позволяет группе программистов параллельно заниматься различными задачами в проекте и писать свои кусочки исходного кода в один и тот же проект. По сути — редактировать одни и те же файлы единовременно. Чтобы после этой работы результат их труда выглядел как единое целое, требуется проводить процедуру синхронизации. Раньше, в эпоху отсутствия систем версионного контроля, это делали вручную. Не спрашивайте как. Это было либо очень топорное решение, когда один программист говорил другому о своих намерениях в одном из файлов с исходным кодом что-то поправить, тогда второй просто не трогал этот файл. Либо, после написания кода проводились ресурсоемкие процедуры сливания результатов работы двух и более программистов в единый исходный код.

Не сложно догадаться, в первом случае скорость реализации разных задач была низкой из-за отсутствия возможности параллельно работать над одним условным файлом. Во втором случае время, которые придется затратить на ручное слияние результатов параллельной работы двух-трех программистов было больше, чем они каждый потратили на свою часть работы. Когда программистам надоело «работать руками», они автоматизировали свою жизнь, изобретя и разработав систему версионного контроля.

Работа системы версионного контроля заключается в реализации трех базовых потребностей:

1. Предоставить каждому программисту в команде проекта актуальную версию исходного кода, имеющуюся на центральном сервере, полностью синхронизированную со всеми — так называемая ветка Master. Процедура получения копии исходного кода называется Pull (в просторечии — «пуллить»).
2. Собирать все изменения в исходном коде от всех программистов (contributors — контрибьютеры). Процедура отправки результатов работы с исходным кодом в общее хранилище называется Push (в просторечии — «пушить»).
3. Показывать разницу между имеющимся в Master коде и новым, давая главным программистам (владельцам проекта или maintainers — мейнтейнерам) инструменты анализа полученного результат и возможность принять предложенные изменения или отказаться от их применения, откатив до предыдущей версии.

Помимо основных функций есть и полезные дополнительные, которые в настоящее время давно переросли в основные:

1. Если программист не является участником проекта, которому разрешено вносить изменения в ветку Master самостоятельно через функцию Push, он может воспользоваться функцией Pull-request. Результат его работы будет отправлен в общее хранилище, но представлен как предложение-запрос на внесение изменений. Мейнтейнеры получат уведомление и смогут посмотреть предложенные изменения в удобной форме (difference), после чего принять его, отказаться от принятия или прокомментировать.
2. В случае возникновения острого желания доработать или видоизменить исходный код, но при отсутствии со стороны владельца (мейнтейнера) желания применять столь радикальные изменения, обычно нарушающие концепцию и (или) подход к разработке, инициатор изменения может сделать «форк». Функция Fork (от англ. вилка) — это создание отдельной версии проекта с исходным кодом, взятым в другом проекте и доработанным по своим лекалам и требованиям. Часть кода при этом не должна меняться, так она является, например, core-функциональность, а так же будет совершенствоваться основным разработчиком, а вот все остальное можно поменять и применять уже по правилам, созданным инициатором изменений (который сделал «форк») и в соответствии с лицензией, установленной для проекта-донора.

**Подведем краткий итог:**

1. Системы версионного контроля бывают разные, но в их основе заложен принцип автоматизации коллективной работы группы программистов с возможностью объединять коллективную работу в единое целое, централизованно хранить программный код, отменять внесенные изменения.
2. По-другому системы ревизионного контроля еще называют репозиториями. Репозиторий — это хранилище, где «лежат» файлы с исходным кодом. Это определение верно для указания на место хранения, но не на метод и принцип организации труда с использованием автоматизации процессов синхронизации результатов работы разных программистов с исходным кодом.
3. Когда вы хотите внести изменения в «чужой» код, они не попадут в него автоматически, их будут рассматривать мейнтейнеры проекта, после чего примут решение о принятии или отказе в принятии изменений. Все системы ревизионного контроля имеют функционал двустороннего общения для взаимодействия внутри одного инструмента программиста-энтузиаста с мейнтейнером.
4. Когда проект очень нравится, но хочется его достаточно радикально изменить и перестроить под себя, а договориться о такой работе с мейнтейнером не получается или не представляется возможным — делайте fork и развивайте свою версию программного продукта на основе чужого, поддерживаемого кода. Связь исходного кода в проекте-родителе останется, так что все «плюшки от папы» вы будете получать и сможете принимать решение об их включении в свой проект (часто новые функции ломают или нарушают работу ваших кардинальных изменений, так что функция проверки совместимости вместо молчаливого обновления не повредит).

### Есть ли жизнь после кода?
Безусловно, жизнь на исходном коде не заканчивается. Программисты помимо написания кода занимаются его тестированием и сборкой.

Тестирование кода или модульное тестирование — практика написания тестов до имплементации (реализации) решения в коде. Сейчас объясню по-русски. До того, как программист напишет программный код, решающий какую-то задачу, он должен придумать критерии и правила оценки успешности исполнения кода. Критерии и правила так же описывается в виде исходного кода (причем внутри проекта) — программируются в виде модульного или единичного теста (еще его называют юнит-тестом от англ. unit-testing). После этого программист разрабатывает решение задачи, запускает тест и проверяет свое решение на выполнение заранее продуманных выходных параметров. Если тест пройден — решение верно. Если нет — не верно. Смысл такого действия в том, чтобы проверять, не привело ли последующее изменение кода в рамках его совершенствования к регрессивным изменениям (не нарушился ли заданный критерий результативности). Если кто-то пришел, исправил написанный ранее код и новый вариант решения задачи провалил тест, значит произошел регресс кода — его ухудшение. Такое изменение нельзя использовать до тех пор, пока новый код не сможет пройти тест. Такая автоматизация тестирования экономит сотни часов работы десятков людей в команде.

---
Далее в книге:
- статический анализ кода,
- проверка кода на безопасность,
- сборка дистрибутива,
- поставка дистрибутива на разработческий сервер,
- отладка кода,
- поставка на тестовые стенды,
- комплексное автоматизированное тестирование,
- выход на ПСИ,
- выход в ПРОМ,
- DevOps.

Под сборкой кода подразумевается не только компиляция. Сборка — комплексная работа превращения исходного кода в дистрибутив.

*Согласно Википедии*: «[Дистрибути́в](https://ru.wikipedia.org/wiki/Дистрибутив) (англ. distribute — распространять) — это форма распространения программного обеспечения».
