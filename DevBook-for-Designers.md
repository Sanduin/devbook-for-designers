# Про код, дистрибутив, сборку дистрибутива, тестирование, приемо-сдаточные испытания, промышленную эксплуатацию
Я пишу этот рассказ с целью закрыть пропасть, образовавшуюся между понятиями «я слышал название, применяю его» и «я понимаю что это значит, могу сам объяснить» в отношении рабочего процесса программистов и тестировщиков.

## Глава I. Программисты

### Как работают программисты
Дисклеймер: в нашем общем случае, программист и кодер, верстальщик и технолог — все на одно лицо: сидят и буквы пишут, отбивая каждую строчку отступами из пробелов или табуляций, назовем их «программистами» для простоты. Что они делают — для нас не существенно, язык программирования или разметки так же не важен. Если продолжать обобщать до маразма, то и работа аналитика по создание модели данных тоже можно рассматривать через призму описанного ниже.

**Аксиома:** программисты пишут код.

Что такое код? Под словом «код» в нашем случае — разработки программного обеспечения — подразумевается написание исходного (программного) кода.

*Согласно Википедии:* «[Исхо́дный код](https://ru.wikipedia.org/wiki/Исходный_код) (также исхо́дный текст) — текст [компьютерной программы](https://ru.wikipedia.org/wiki/Компьютерная_программа) на каком-либо [языке программирования](https://ru.wikipedia.org/wiki/Язык_программирования) или [языке разметки](https://ru.wikipedia.org/wiki/Язык_разметки), который может быть прочтён человеком. В обобщённом смысле — любые входные данные для [транслятора](https://ru.wikipedia.org/wiki/Транслятор). Исходный код транслируется в исполняемый код целиком до запуска программы при помощи [компилятора](https://ru.wikipedia.org/wiki/Компилятор) или может исполняться сразу при помощи [интерпретатора](https://ru.wikipedia.org/wiki/Интерпретатор)».

*Код записывается в файл.* Файл текстовый, в технических терминах обозначается как plain-text. Программа, которую пишет программист, может состоять как из одного файла (простейший, если не сказать примитивный случай), из десятков, сотен, тысяч, а иногда и десятков тысяч файлов с исходными кодами, порой на разных языках (не только программирования, но и разметки). В разных языках программирования различаются модели описания ссылок на так называемые модули — фрагменты исходного кода, вынесенные в отдельный файл.

*Зачем выносят исходный код в отдельный файл?* По разным причинам, начиная с разделения проекта на логические куски — файлы, — исходный код в которых написан на разных языках, заканчивая простейшим удобством разработки. Удобством в таком случае может стать как физическое ограничение plain-text файла: по достижению какого-то большого размера такой файл вызывает проблемы при чтении (исходный код читают). Или, например, разделяют, чтобы вынести в отдельный файл какие-то части программного кода, повторяющиеся во многих местах (функции и процедуры), чтобы поддерживать их независимо от основного кода.

### Куда складывают файлы с исходным кодом и как с ними работают?
Общемировая практика предлагает отказываться от хранения исходного кода только на рабочей станции программиста в единственном экземпляре. Не только по причине ненадежности одного такого хранилища и риска потерять все и сразу, так как нет копии на случай неработоспособности рабочей станции. В основном из-за того, что над одним проектом могут, а по сути должна, работать группа специалистов: программисты, верстальщики, кодеры, аналитики и другие, в том числе и администраторы. Да-да, у всех них есть задачи автоматизации. Если у программиста это задача единственная, то у его коллег становится таковой лишь в последнее время. Пусть, они не постоянно пишут исходный код, но им регулярно приходится создавать и править, например, конфигурационные файлы самых разных систем — такие файлы настроек и конфигураций так же имеет смысл централизованно хранить вместе с программным продуктом и его исходным кодом.

*Централизованно хранить* означает использовать одну из [систем версионного хранения](https://ru.wikipedia.org/wiki/Система_управления_версиями) (еще их называют системами ревизионного хранения или системами управления версиями). Такие системы работают по особому принципу и различаются некоторыми нюансами внутренних процессов, команд и другими тонкими особенностями, из-за которых одни программисты любят одни системы, другие — другие ;). Из самых распространенных у нас в Сбербанке система ревизионного контроля (хранения) отметим Stash от разработчиков Jira и BitBucket, купленный разработчиком Jira — компанией Atlassian — некоторое время назад. Еще применяют, в основном подпольно, GitLab и в чистом виде Git. Есть и другие системы, например, Mercurial или SVNx (Subversions), но про них в банке только говорят, но не используют.

Итого, написанный программистом и сохраненный в файл проекта код попадает в систему версионного контроля и хранится как на локальной машине, так и в централизованном хранилище где-то на сервере, для которого есть резервирование. Если программист один — нет никаких проблем, он может копировать рабочую папку проекта и не заботиться о версионном контроле (в теории), но что делать, когда программистов много?

### Нафига нужна систем версионного контроля и как она работает?
О, это прекрасный вопрос. Система версионного контроля позволяет группе программистов параллельно заниматься различными задачами в проекте и писать свои кусочки исходного кода в один и тот же проект. По сути — редактировать одни и те же файлы единовременно. Чтобы после этой работы результат их труда выглядел как единое целое, требуется проводить процедуру синхронизации. Раньше, в эпоху отсутствия систем версионного контроля, это делали вручную. Не спрашивайте как. Это было либо очень топорное решение, когда один программист говорил другому о своих намерениях в одном из файлов с исходным кодом что-то поправить, тогда второй просто не трогал этот файл. Либо, после написания кода проводились ресурсоемкие процедуры сливания результатов работы двух и более программистов в единый исходный код. Не сложно догадаться, в первом случае скорость реализации разных задач была низкой из-за отсутствия возможности параллельно работать над одним условным файлом. Во втором случае время, которые придется затратить на ручное слияние результатов параллельной работы двух-трех программистов было больше, чем они каждый потратили на свою часть работы. Когда программистам надоело «работать руками», они автоматизировали свою жизнь, изобретя и разработав систему версионного контроля.

Работа системы версионного контроля заключается в реализации трех базовых потребностей:
1. Предоставить каждому программисту в команде проекта актуальную версию исходного кода, имеющуюся на центральном сервере, полностью синхронизированную со всеми — так называемая ветка Master. Процедура получения копии исходного кода называется Pull (в просторечии — «пуллить»).
2. Собирать все изменения в исходном коде от всех программистов (contributors — контрибьютеры). Процедура отправки результатов работы с исходным кодом в общее хранилище называется Push (в просторечии — «пушить»).
3. Показывать разницу между имеющимся в Master коде и новым, давая главным программистам (владельцам проекта или maintainers — мейнтейнерам) инструменты анализа полученного результат и возможность принять предложенные изменения или отказаться от их применения, откатив до предыдущей версии.

Помимо основных функций есть и полезные дополнительные, которые в настоящее время давно переросли в основные:
1. Если программист не является участником проекта, которому разрешено вносить изменения в ветку Master самостоятельно через функцию Push, он может воспользоваться функцией Pull-request. Результат его работы будет отправлен в общее хранилище, но представлен как предложение-запрос на внесение изменениq. Мейнтейнеры получат уведомление и смогут посмотреть предложенные изменения в удобной форме (difference), после чего принять его, отказаться от принятия или прокомментировать.
2. В случае возникновения острого желания доработать или видоизменить исходный код, но при отсутствии со стороны владельца (мейнтейнера) желания применять столь радикальные изменения, обычно нарушающие концепцию и (или) подход к разработке, инициатор изменения может сделать «форк». Функция Fork (от англ. вилка) — это создание отдельной версии проекта с исходным кодом, взятым в другом проекте и доработанным по своим лекалам и требованиям. Часть кода при этом не может быть изменена, так она является, например, core-функциональность, а так же будет совершенствоваться основным разработчиком, а вот все остальное можно поменять и применять уже по правилам, созданным инициатором изменений (который сделал «форк»).

**Подведем краткий итог:**

1. Системы версионного контроля бывают разные, но в основе их заложен принцип автоматизации коллективной работы группы программистов с возможностью отменять какие-то изменения.
2. По-другому системы ревизионного контроля еще называют репозиториями. Репозитории — это хранилища, где «лежат» файлы с исходным кодом. Это определение верно для указания на место хранения, но не на метод и принцип организации труда с использованием автоматизации процессов синхронизации результатов работы разных программистов над один исходным кодом.
3. Когда вы хотите внести изменения в «чужой» код, они не попадут в него автоматически, из будут рассматривать мейнтейнеры проекта, после чего примут решение о принятии или. отклонении изменений. Все системы ревизионного контроля имеют функционал двустороннего общения для взаимодействия внутри одного инструмента программиста-энтузиаста с мейнтейнером.
4. Когда проект очень нравится, но хочется его достаточно радикально изменить и перестроить под себя, а договориться о такой работе с мейнтейнером не получается или не представляется возможным — делайте fork и развивайте свою версию программного продукта на основе чужого, поддерживаемого кода. Связь исходного кода в проекте-родителе останется, так что все «плюшки от папы» вы будете получать и сможете принимать решение об их включении в свой проект (часто новые функции ломают или нарушают работу ваших кардинальных изменений, так что функция проверки совместимости вместо молчаливого обновления точно не вредит).

### Есть ли жизнь после кода?
Безусловно, жизнь на исходном коде не заканчивается. Программисты помимо написания кода занимаются его тестированием и сборкой. Тестирование кода или модульное тестирование — практика написания тестов до имплементации (реализации) решения в коде. Сейчас объясню по-русски. До того, как программист напишет программный код, решающий какую-то задачу, он должен придумать критерии и правило оценки успешности выполнения этой задачи. Этот критерий описывается в виде все того же исходного кода — программируется в виде модульного или единичного теста (еще его называют юнит-тестом от англ. unit-testing). После этого программист разрабатывает решение задачи, запускает тест и проверяет свое решение на выполнение заранее продуманных выходных параметров. Если тест пройден — решение верно. Если нет — не верно. Смысл такого действия в том, чтобы проверять, не привело ли последующее изменение кода в рамках его совершенствования к регрессивным (ухудшилось) изменениям. Если кто-то пришел и исправил написанный ранее код и новый вариант решения задачи провалил тест, значит произошел регресс кода — его ухудшение. Такое изменение нельзя использовать до тех пор, пока новый код не сможет пройти тест. Это автоматизация, экономящая сотни часов работы десятков людей в команде.




---
Под сборкой кода подразумевается не только компиляция. Сборка — комплексная работа превращения исходного кода в дистрибутив.

*Согласно Википедии*: «[Дистрибути́в](https://ru.wikipedia.org/wiki/Дистрибутив) (англ. distribute — распространять) — это форма распространения программного обеспечения».

